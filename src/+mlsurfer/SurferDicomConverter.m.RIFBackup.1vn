classdef SurferDicomConverter < mlfourd.AbstractDicomConverter
	%% SURFERDICOMCONVERTER is a concrete strategy for interfaces DicomConverter, AbstractConverter;
    %                          a facade for freesurfer commands
    %  Version $Revision: 2336 $ was created $Date: 2013-01-23 12:41:12 -0600 (Wed, 23 Jan 2013) $ by $Author: jjlee $,  
 	%  last modified $LastChangedDate: 2013-01-23 12:41:12 -0600 (Wed, 23 Jan 2013) $ and checked into svn repository $URL: file:///Users/jjlee/Library/SVNRepository_2012sep1/mpackages/mlsurfer/src/+mlsurfer/trunk/SurferDicomConverter.m $ 
 	%  Developed on Matlab 7.13.0.564 (R2011b) 
 	%  $Id: SurferDicomConverter.m 2336 2013-01-23 18:41:12Z jjlee $ 
 	%  N.B. classdef (Sealed, Hidden, InferiorClasses = {?class1,?class2}, ConstructOnLoad) 

    properties (Constant)
        % for construction of structInfo
        INFO_EXPRESSION = ...
'(?<index>\d+)\s+(?<seq_type>\w+)\s+(?<status>\w+)\s+(?<dim1>\d+)\s+(?<dim2>\d+)\s+(?<dim3>\d+)\s+(?<dim4>\d+)\s+(?<siemens>\S+)';
        SCAN_INFO       = 'scan.info';
        unpackFolders   = {'unpack'};
    end
  
    methods (Static)
        
        function this       = convert(modalPth)
            this = mlsurfer.SurferDicomConverter(modalPth);
            this.unpack(this.unpackPath);            
        end % static convert
        function              parconvertStudy(studyPth, patt)
            if (~exist('patt', 'var'))
                patt = '*'; end
            dt  = mlfourd.DirTool(fullfile(studyPth, patt));
            dns = dt.fqdns;
            matlabpool close force local
            matlabpool local
            parfor d = 1:length(dns)
                try
                    mlsurfer.SurferDicomConverter.convertSession(dns{d});
                catch ME
                    handwarning(ME);
                end
            end
            matlabpool close
        end % static convertStudy  
        function this       = convertSessions(patt)
            dt = mlfourd.DirTool(patt);
            for s = 1:length(dt)
                fprintf('SurferDicomConverter will convert:  %s\n', dt.fqdns{s});
                this = mlsurfer.SurferDicomConverter.convertSession(dt.fqdns{s});
            end
        end
        function this       = convertSession(sessionPth)
            try
                this = mlsurfer.SurferDicomConverter.createFromSessionPath(sessionPth);
                this.unpack(this.unpackPath);
            catch ME
                handwarning(ME);
            end
        end % static convertSession  
        function this       = createFromSessionPath(spth)
            %% CREATEFROMSESSIONPATH only instantiates the class at a modality-path
            %  obj = SurferDicomConverter.createFromModalityPaty(modality_path)
            
            import mlsurfer.*;
            mpth = firstExistingFile(spth, SurferDicomConverter.modalityFolders);
            this = SurferDicomConverter.createFromModalityPath(mpth);
        end
        function this       = createFromModalityPath(mpth)
            %% CREATEFROMMODALITYPATH only instantiates the class at a modality-path
            %  obj = SurferDicomConverter.createFromModalityPaty(modality_path)
            
            this = mlsurfer.SurferDicomConverter(mpth);
        end
        function  cal       = unpackDicom(dcmdir, targdir, unpackInfo)
            %% UNPACKDICOM is a facade for unpacksdcmdir -fsfast
            %  Usage:  cal = SurferDicomConverter.unpackDicom(dcmdir, targdir, unpackInfo)
            %          ^ surfer stdout embedded in CellArrayList
            %                                        unpackInfo is a struct-array ^  
            %                                        fields:  index, seq_type, ext, name
            %                                        e.g.,    18,    mprage,   mgz, 001.mgz
            
            assert(~isstructEmpty(unpackInfo));
            cal   = mlpatterns.CellArrayList;
            for n = 1:length(unpackInfo) %#ok<*FORFLG>

                r_n = '';
                try
                    assert(isnumeric(unpackInfo(n).index   ) && ~isempty(unpackInfo(n).index));
                    assert(   ischar(unpackInfo(n).seq_type) && ~isempty(unpackInfo(n).seq_type));
                    assert(   ischar(unpackInfo(n).ext     ) && ~isempty(unpackInfo(n).ext));
                    assert(   ischar(unpackInfo(n).name    ) && ~isempty(unpackInfo(n).name));
                    niiList = sprintf(' -run %i %s %s %s ', ...
                              unpackInfo(n).index, unpackInfo(n).seq_type, unpackInfo(n).ext, unpackInfo(n).name);     
                    [~,r_n] = mlbash(['unpacksdcmdir -src ' dcmdir ' -targ ' targdir ' -fsfast ' niiList]);
                    cal.add(r_n);
                catch ME
                    handwarning(ME, r_n);
                end
            end
        end  
        function structInfo = infoFile2structInfo(fil)
            structInfo = mlsurfer.SurferDicomConverter.parseInfoCell( ...
                             mlfourd.FilesystemRegistry.textfileToCell(fil));
        end % static infoFile2structInfo
        function [s,r]      = scanDicom(dcmdir, targdir)
            %% SCANDICOM is a facade for unpacksdcmdir -scanonly
            
            import mlfourd.* mlsurfer.*;
            infofile  = fullfile(targdir, SurferDicomConverter.SCAN_INFO);
            if (lexist(infofile, 'file'))
                s = 0; r = cell2str(FilesystemRegistry.textfileToCell(fil), 't');
            else
                [s,r] = mlbash(['unpacksdcmdir -src ' dcmdir ' -targ ' targdir ' -scanonly ' infofile]);
            end
        end 
    end % static methods
    
	methods
      
        function                rename(this, unpackPth, fslPth)
            %% RENAME

            import mlfourd.*;
            unpacked = DirTool(unpackPth);
            ensureFolderExists(fslPth);
            for d = 1:length(unpacked.dns)
                fslName = this.namingRegistry_.fslName(unpacked.dns{d});
                series  = DirTool(fullfile(unpackPth, unpacked.dns{d}, ''));
                for s = 1:length(series.dns)
                    niftis = DirTool(fullfile(unpackPth, unpacked.dns{d}, series.dns{s}, '*.nii'));
                    for n = 1:length(niftis.fqfns)
                        copyfile(niftis.fqfns{n}, ...
                                 fullfile(fslPth, [fslName '_' niftis.fns{n}]), 'f');
                    end
                end
            end
        end % rename
        function structInfo   = dicomQuery(this, dcmPth, targPth)
 			%% DICOMQUERY
            %  Usage:  structInfo = obj.dicomQuery([dicom_path, target_path])
            %          ^ struct-array for session, one struct per series;
            %            fields:  index, seq_type, status, dim1, dim2, dim3, dim4, siemens
            
            import mlsurfer.*;
            if ( exist('dcmPth',  'var')); this.dicomPath  = dcmPth;  end
            if ( exist('targPth', 'var')); this.unpackPath = targPth; end
            
            infofile = fullfile(this.unpackPath, this.SCAN_INFO);
            if (lexist(infofile, 'file'))
                structInfo = SurferDicomConverter.infoFile2structInfo(infofile);
            else
                structInfo = this.dicoms2structInfo;
            end            
 		end % dicomQuery  
        function structInfo   = dicoms2structInfo(this)
            %% DICOM2STRUCTINFO
            
            import mlsurfer.*;
            [s,r]      = SurferDicomConverter.scanDicom(this.dicomPath, this.unpackPath); 
            assert(0 == s, r);
            structInfo = SurferDicomConverter.parseInfoString(r);
        end % dicoms2structInfo 
        function unpackInfo   = structInfo2unpackInfo(this, structInfo)
            %% STRUCTINFO2UNPACKINFO
            %  Usage:  unpackInfo = obj.structInfo2unpackInfo(structInfo)
            %                                      ^ cf. dicomQuery
            %          ^ struct-array for session, one struct per series
            %            fields:   index, seq_tuype, ext, name, dicom_path, target_path
            
            import mlsurfer.* mlfourd.*;
            n       = 0;
            unpackInfo = struct([]);
            for s = 1:length(structInfo)
                n = n + 1;
                unpackInfo(n).index       = structInfo(s).index;
                unpackInfo(n).seq_type    = structInfo(s).seq_type;
                unpackInfo(n).ext         = 'nii';
                unpackInfo(n).name        = sprintf('%03u.%s', unpackInfo(n).index, unpackInfo(n).ext);
                unpackInfo(n).dicom_path  = this.dicomPath;
                unpackInfo(n).target_path = this.unpackPath;
            end
            
        end % structInfo2unpackInfo
        function [str, degen] = listUniqueInfo(this)
            import mlfourd.*;
             dc          = DicomSession.createFromPaths(this.dicomPath);
            [str, degen] = dc.listUniqueInfo('seq_type');
        end % listUniqueInfo
    end % methods    
    
    %% PROTECTED
      
    methods (Static, Access = 'protected')
        
        % Direct calls to Freesurfer commands        
        function  structInfo  = parseInfoFile(fqfn)
            %% PARSEINFOFILE
            %  Usage:   structInfo = SurferDicomConverter.parseInfoFile(fqfn)
            %           ^ struct-array for scan session, one struct per scan series;
            %             fields:  index, seq_type, status, dim1, dim2, dim3, dim4, siemens
            %  Uses:   parseInfoCell

            structInfo = mlsurfer.SurferDicomConverter.parseInfoCell( ...
                         mlfourd.FilesystemRegistry.textfileToCell(fqfn));
        end
        function  structInfo  = parseInfoCell(ca)
            %% PARSEINFOCELL
            %  Usage:   structInfo = SurferDicomConverter.parseInfoCell(cell_of_string_lines)
            %                                                    ^ one element per line of text generated by
            %                                                      unpacksdcmdir
            %           ^ struct-array for scan session, one struct per scan series;
            %             fields:  index, seq_type, status, dim1, dim2, dim3, dim4, siemens
            
            assert(~isempty(ca) && ~isempty(ca{1}), 'ca was empty');
            try
                for j = 1:length(ca)
                    [~, info]     = regexp(ca{j},  mlsurfer.SurferDicomConverter.INFO_EXPRESSION, 'tokens', 'names');
                    if (~isempty(info))
                        info.index    = str2double(info.index);
                        info.dim1     = str2double(info.dim1);
                        info.dim2     = str2double(info.dim2);
                        info.dim3     = str2double(info.dim3);
                        info.dim4     = str2double(info.dim4);
                        info.dims     = [info.dim1 info.dim2 info.dim3 info.dim4];
                        structInfo(j) = info; %#ok<AGROW>
                    end
                end
            catch ME
                handexcept(ME);
            end
        end
        function  structInfo  = parseInfoString(info)
            %% PARSEINFOSTRING
            %  Usage:   structInfo = SurferDicomConverter.parseInfoString(info_string)
            %           ^ struct-array for scan session, one struct per scan series;
            %             fields:  index, seq_type, status, dim1, dim2, dim3, dim4, siemens
            %  Uses:  parseInfoCell
            
            EXPRESS    = 'Done scanning \w+\s+\w+\s+\d+\s+\d+\S\d+\S\d+\s+\w+\s+\d+\s+[-]+\s+';
            matchend   = regexp(info, EXPRESS, 'end');
            info       = info(matchend(end)+1:end); % choose last instance only
            matchstart = regexp(info, '\n');
            ca         = cell(1,length(matchstart));
            ca{1}      = info(1:matchstart(1));
            for m = 2:length(matchstart)
                ca{m}  = info(matchstart(m-1)+1:matchstart(m));
            end
            structInfo = mlsurfer.SurferDicomConverter.parseInfoCell(ca);
        end
        function  ca          = seqTypes(unpackInfo)
            
            ca = cell(1,length(unpackInfo));
            for r = 1:length(unpackInfo)
                ca{r} = unpackInfo(r).seq_type;
            end
        end
    end % protected static methods

    methods (Access = 'protected')
 		function this = SurferDicomConverter(mrpth)
 			%% SURFERDICOMCONVERTER 
 			%  Usage:  cvert = SurferDicomConverter(MR_path)
			
            this = this@mlfourd.AbstractDicomConverter(mrpth);
 		end % ctor 
    end % protected methods  
	%  Created with Newcl by John J. Lee after newfcn by Frank Gonzalez-Morphy 
end

